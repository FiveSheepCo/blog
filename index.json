[{"content":"","permalink":"https://blog.quintschaf.com/","title":"FiveSheep Blog"},{"content":"QSChatView: A beautiful data-driven chat view for iOS and macOS In today\u0026rsquo;s fast-paced world, chat applications have become an essential means of communication. With the increasing popularity of SwiftUI and its easy-to-use, declarative syntax, developers are always on the lookout for reliable libraries to build messaging interfaces for their apps. Look no further! FiveSheep has created a SwiftUI library called QSChatView that provides a customizable chat view for rendering static and interactive chat conversations, similar to popular messaging apps like WhatsApp and Signal.\nQSChatView is a fully interactive, data-driven chat view that works on iOS, macOS, and Catalyst. It supports light and dark mode, and offers various customization options.\nKey Features QSChatView offers a range of features that make it an ideal choice for creating chat interfaces in your SwiftUI apps. Some of the key features include:\nData-driven chat view: The chat view is fully data-driven, allowing you to easily connect it to your app\u0026rsquo;s data source, whether it\u0026rsquo;s a server, database, or local cache.\nInteractive elements: The library supports various interactive elements, such as typing indicators, which help create a more engaging user experience.\nCustomizable appearance: You can easily customize the appearance of your chat interface using the ChatConfigBuilder to match your app\u0026rsquo;s design and requirements.\nRich media support: QSChatView allows you to incorporate rich media, such as images and videos1, into your chat conversations, providing a more immersive experience for your users.\nCross-platform compatibility: The library works seamlessly on iOS, macOS, and Catalyst, making it a perfect choice for developers looking to create chat interfaces across multiple platforms.\nLight and dark mode support: QSChatView supports both light and dark modes, ensuring that your chat interface will look great regardless of the user\u0026rsquo;s system preferences.\nSwift Package Manager integration: Installing and managing QSChatView is easy thanks to its Swift Package Manager integration. Just add the library\u0026rsquo;s URL to your project\u0026rsquo;s dependencies and you\u0026rsquo;re good to go.\nWith these features and more, QSChatView makes it simple to build beautiful, data-driven chat applications for iOS and macOS.\nCustomization Options One of the key features of QSChatView is the ability to customize the chat view according to your app\u0026rsquo;s design and requirements. Using the ChatConfigBuilder, you can easily adjust many settings and behaviors.\nHere\u0026rsquo;s an example of how to create a basic, custom chat configuration:\nlet config = ChatConfigBuilder() .showTextField() .showTimestamps(false) .withScrollingBehavior(.adaptive) .build() Installing QSChatView To install QSChatView, simply add the following URL to your Swift Package Manager dependencies:\nhttps://github.com/quintschaf/qschatview.git Getting Started with QSChatView Basic Example Here is a basic example with a single chat participant and message:\nimport SwiftUI import QSChatView struct MyChatView: View { // Instantiate a `ChatController` with some initial messages @StateObject var controller = ChatController(messages: [ ChatMessage(from: .me, content: .text(\u0026#34;Hello world\u0026#34;)), ]) var body: some View { // Render the chat view with our controller QSChatView(controller).padding() } } Advanced Example A more advanced example with a modified config, multiple participants and a custom chat backend:\nimport SwiftUI import QSChatView class MyChatData: ObservableObject { @Published var controller: ChatController @Published var chatPartner: ChatParticipant init() { // Build chat config. // You can also use `ChatConfig.default` here. let config = ChatConfigBuilder() .showTextField() .showTimestamps(false) .withScrollingBehavior(.adaptive) .build() // In this example we specify a fixed set of initial messages. // // In a real-world application, you would probably load messages // from a server or database, or restore them from a local cache. let messages: [ChatMessage] = [ ChatMessage(from: .me, content: .text(\u0026#34;Hey John, are you there?\u0026#34;)) ] // Create a chat controller with our messages and config self.controller = ChatController(messages: messages, config: config) // Create a chat partner self.chatPartner = ChatParticipantBuilder().withName(\u0026#34;John Doe\u0026#34;).build() } // This is meant as an example on how to interact with the chat controller. // It also serves as an introduction to the `ChatMessagePromise` API. func startMessageTimer() { // Run this block every 5 seconds Timer.scheduledTimer(withTimeInterval: 5, repeats: true) { _ in // Add a temporary message with a typing indicator. // In this case, John Doe is shown as typing. let messagePromise = self.controller.sendPromise(from: self.chatPartner) // Wait 2 seconds before resolving the promise DispatchQueue.main.asyncAfter(deadline: .now() + 2) { // Resolve the promise with the actual message messagePromise.fulfill(withContent: .text(\u0026#34;Hello from John!\u0026#34;)) // In the case that John stops typing without sending // a message, we can use `messagePromise.reject()` instead. } } } } struct MyChatView: View { @StateObject var chat = MyChatData() // Called when the user sends a message through the chat view func handleMessageSent(_ message: String) { // Messages are added to the controller before this callback is called. // // We can do additional processing here, such as sending the message // to a server, logging it, updating statistics, and so on. // // In this example, we just print the message to the console. print(\u0026#34;User sent message: \\(message)\u0026#34;) } var body: some View { // Render the chat view with our controller and callback QSChatView(chat.controller, onMessageSent: handleMessageSent) .padding() .onAppear { chat.startMessageTimer() } } } Conclusion QSChatView is an excellent SwiftUI library for creating customizable and interactive chat views for your iOS and macOS applications. The examples provided in the README demonstrate how easy it is to implement and customize the chat view according to your application\u0026rsquo;s requirements. By leveraging the power of SwiftUI and QSChatView, you can create beautiful, data-driven chat applications for iOS and macOS.\nGive QSChatView a try by visiting the GitHub repository and start building amazing chat experiences for your users today!\nImages are implemented, but Video and Audio is not yet supported.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.quintschaf.com/posts/qschatview/","title":"Introducing ChatView"},{"content":"","permalink":"https://blog.quintschaf.com/posts/","title":"Posts"},{"content":"Introducing MapItemPicker: A Powerful Location Picker for SwiftUI As an app developer, there are times when you need to create a view that allows users to find and select locations. However, Apple doesn\u0026rsquo;t provide a built-in view for this in their frameworks, and much of the information displayed in the Maps app that makes it easy to search for and discover map items is not exposed on MKMapItem. That\u0026rsquo;s why we created MapItemPicker, a simple, yet highly customizable and powerful location picker for SwiftUI that uses data from MapKit, OpenStreetMaps, and Wikidata to deliver a comprehensive map item picker experience.\nWhat is MapItemPicker? MapItemPicker is a SwiftUI library that provides an easy-to-use and customizable location picker for your app. It combines data from MapKit, OpenStreetMaps, and Wikidata to offer a beautiful and feature-rich map item picker.\nThe library has built-in support for annotations and overlays, making it simple to add custom markers and lines on the map. Additionally, it provides a powerful search and filtering functionality, allowing users to quickly find the location they need.\nGetting Started To start using MapItemPicker, simply add it to your project via Swift Package Manager. Once installed, you can use the convenience method to add a simple picker to your app:\n.mapItemPickerSheet(isPresented: $showsSheet) { mapItem in print(\u0026#34;Map Item:\u0026#34;, mapItem) } For more advanced use cases, you can customize the picker using the parameters of MapItemPicker view:\nMapItemPicker( annotations: [MKPointAnnotation.chicago], overlays: [MKPolyline.newYorkToLosAngeles], showsLocationButton: false, additionalTopRightButtons: [ .init( imageName: \u0026#34;magnifyingglass\u0026#34;, handler: { searchControllerShown = true } ) ], initialRegion: MKCoordinateRegion.unitedStates, standardView: { Text(\u0026#34;Standard View\u0026#34;) }, searchControllerShown: $searchControllerShown, standardSearchView: { Text(\u0026#34;Search View\u0026#34;) } ) Check out the full README for more examples and detailed usage instructions.\nLocalization MapItemPicker includes localizations for categories, titles of sections in the views, and other strings. Currently, only English and German are supported. If you can provide localization for any other language, please submit a PR. You can copy the strings from the English Localizable.strings file at Sources/MapItemPicker/Resources/en.lproj. It\u0026rsquo;s not a lot of localization keys, and you\u0026rsquo;ll probably be done in 5 minutes.\nFuture Plans and Contributions MapItemPicker is under active development, and there are many exciting features planned for future releases, including:\nImproved location type handling More data sources Editing opening hours and reporting back to OpenStreetMaps Additional filters in search Unit tests and UI tests Compiled documentation If you\u0026rsquo;re interested in contributing to MapItemPicker or have any suggestions, feel free to open an issue or submit a pull request.\nConclusion MapItemPicker is an essential tool for developers looking to add a powerful and customizable location picker to their SwiftUI apps. With its combination of MapKit, OpenStreetMaps, and Wikidata, MapItemPicker offers a comprehensive solution that is both user-friendly and feature-rich. By integrating this library into your projects, you\u0026rsquo;ll save valuable development time and provide your users with an intuitive and enjoyable experience when searching for and selecting locations.\nDon\u0026rsquo;t hesitate to give MapItemPicker a try and take advantage of its capabilities to enhance your app\u0026rsquo;s functionality. Remember that contributions are always welcome, so feel free to join the project and help improve this fantastic tool even further.\nHappy coding!\n","permalink":"https://blog.quintschaf.com/posts/map-item-picker/","title":"Introducing MapItemPicker"},{"content":"SwiftKey is gone On September 28th 2022, Microsoft announced that it would pull the popular keyboard SwiftKey from Apple\u0026rsquo;s AppStore. The announcement came suddenly and without much time to react. As of October 5th 2022, SwiftKey is no longer available on the AppStore.\nIf you\u0026rsquo;re one of the people impacted, you\u0026rsquo;ll now have to make a hard decision:\nEither keep using SwiftKey or find a new Keyboard to use.\nThis is a bit of a dilemma, since none of these options are good. Starting a few days ago, many people have been reporting issues with SwiftKey. Quite the coincidence that a keyboard which used to run perfectly for years is suddenly misbehaving a few days before being shut down\u0026hellip; Anyway, even if it would work fine, it\u0026rsquo;s not getting any updates and as soon as you get a new device, it\u0026rsquo;s gone.\nNow, choosing another keyboard is pretty hard. Ideally it should have a similar feature set to SwiftKey, behave similarly and be easy enough to use and customize. Just like SwiftKey, it should also be free.\nMyKeyboard to the rescue It just so happens that we\u0026rsquo;re developing an app called MyKeyboard.\nIt has tons of features, it\u0026rsquo;s easy to use and customize, and — best of all — it\u0026rsquo;s free. We do have a paid version, but you won\u0026rsquo;t need it in order to do any of the things you\u0026rsquo;re used to from SwiftKey.\nTo make migration easier we have published a new version, which lets you import your custom word list from SwiftKey. That\u0026rsquo;s possible because Microsoft provides a website for downloading your data (https://data.swiftkey.com).\nWe would\u0026rsquo;ve loved to migrate other settings too, sadly the export only includes your custom word list and nothing else that we could use to make certain changes automatically.\nHow to migrate to MyKeyboard Simply download the app from here: MyKeyboard on the AppStore.\nAfter installing MyKeyboard and going through the onboarding screen (which should only take up a minute of your time), simply go to the Settings tab and tap on Import Data from SwiftKey.\nThe following screen will guide you through exporting your data from SwiftKey and importing them into MyKeyboard. It\u0026rsquo;s a very simple process and shouldn\u0026rsquo;t take up much of your time.\nWhy you should switch We support almost all features you\u0026rsquo;re used to from SwiftKey:\nIntelligent spell checking and word suggestions Support for number and emoji rows Support for quick-period and quick-ellipsis Support for tactile feedback, as well as typing sounds Quick emoji key and a native emoji picker Multi language support UI translated into many of the most-used languages Regional key layouts like QWERTY, QWERTZ, AZERTY, JCUKEN, 두벌식 etc. Spell checking and suggestions in multiple languages at once Beautifully handcrafted themes Additionally, we have many exclusive features SwiftKey never had:\nA novel and extremely fast way of deleting words and sentences Simply hold the deletion key and swipe to the left for precise deletion. \u0026hellip;or just use the old and boring way of deleting. We do have that too. Swipe-down keys in the style of the iPad keyboard Quick access to a second key action by swiping down on a key Customizable delay to trigger the long-press action Emoji suggestions (type fire and get 🔥 as a suggestion) Dedicated keyboard modes for accessibility Left-handed and right-handed modes Split the keyboard into two by dragging from the center with two fingers Merge the keyboard again by dragging towards the center with both fingers \u0026hellip;and a lot more! Why you shouldn\u0026rsquo;t switch If you heavily rely on Swipe Typing, MyKeyboard isn\u0026rsquo;t (yet) for you.\nA few features are still missing, the most important one being Swipe Typing. We\u0026rsquo;re working hard on providing this feature as soon as possible, but it has proven very hard to implement correctly, especially considering MyKeyboard\u0026rsquo;s unique design (keys can be customized almost infinitely and while swiping, custom key configurations have to be taken into consideration).\nThere might be a few rough edges here and there, since we\u0026rsquo;re a small company of only two people and we don\u0026rsquo;t have the same resources Microsoft has. But we\u0026rsquo;re very dedicated to our products and we\u0026rsquo;re improving MyKeyboard all the time. We\u0026rsquo;re also using MyKeyboard ourselves, so if there are any issues they\u0026rsquo;ll probably annoy us too, which is a great motivation to fix them!\nAbout the Pro version MyKeyboard offers some advanced features for power users, which are only available in the Pro version.\nLayout editor\nIn the free edition, we offer the Keyboard Builder: an easy way to quickly get a nice layout going. Some advanced building blocks are paid, but they\u0026rsquo;re all pretty specific to MyKeyboard. We don\u0026rsquo;t put basic or experimental features behind a paywall.\nThe layout editor available in the Pro version allows you to fully customize every aspect of the keyboard layout. You can create any layout you can think of and design spezialized keyboards for tasks that are otherwise hard to do on a phone, such as writing Markdown or Regular Expressions. Additionally, you can dive deep into key actions and customize the tap action, hold action, subkeys, sizing and more.\nTheme editor\nIn the free version, we offer a theme mimicking the default iOS look, a flat-design theme and a special Slava Ukraini theme supporting the heroes fighting against the Russian invaders in Ukraine.\nWe also offer a few paid theme packs, as well as a full theme editor, which includes all paid themes.\nThe theme editor in the Pro version offers a fully fledged theme editor, where you can customize every aspect of the keyboard\u0026rsquo;s look and feel. From font and text size over paddings, margins and gap sizes all the way to colors, shadows, and even background images.\nGetting the Pro version\nIf you wanna get the Pro version directly, you can do it here: MyKeyboard Pro on the AppStore.\nIf you already have the free version, you can unlock all features of the Pro version as an in-app purchase. There is no difference between the IAP version and the Pro version on the AppStore.\n","permalink":"https://blog.quintschaf.com/posts/migrating-from-swiftkey/","title":"Migrating from SwiftKey"},{"content":"Welcome to our blog! We are FiveSheep (formerly known as Quintschaf), a small software engineering company based in Estonia.\nHistory In 2020, shortly after the Covid pandemic started manifesting, we (Jann and Marco) founded our company: Quintschaf GbR. This was a first for both of us, there were many things to figure out — for example how to get a business bank account — and finding a way to efficiently work together over a medium-large distance across Germany. Things weren\u0026rsquo;t easy at the beginning, none of us knew how to manage multiple projects while keeping track of an always growing list of ToDos and still being able to ship well-rounded releases with a minimal amount of bugs. I\u0026rsquo;m happy to say that we\u0026rsquo;ve figured all of these things out and business is going better day by day.\nOur first app - NineList The first app we released was a \u0026ldquo;smart\u0026rdquo; shopping list, called 9List (later renamed to NineList). We worked hard on this project and we believed that this app would be incredibly helpful to many people, especially during the pandemic. The app essentially used location-based notification triggers to show shopping list items on the lock-screen upon entering a supermarket.\nPeople didn\u0026rsquo;t have to remove their masks to unlock their phones and we saw this as a big opportunity, especially because it took Apple a long time to release their more mask-friendly iOS updates including the \u0026ldquo;Unlock using Apple Watch\u0026rdquo; functionality.\nSadly, the app flopped. We couldn\u0026rsquo;t get any real visibility on the AppStore and we didn\u0026rsquo;t have funds for marketing, so we gave up and and went back to the drafting board. A few years later we did release a few more quality of life updates, but the app never really took off. Anyway, we learned a lot from this experience and it was a great way to get started.\nOur biggest hit - MyKeyboard Jann had been working on a Keyboard for iOS, called OpenKeyboard. It was a very interesting project — a fully customizable keyboard. Jann had been maintaining it in his free-time, it was a pretty technical app and the user base consisted mostly of tech-savvy people who knew their way around complex software. After talking about it for a few days we decided to migrate the project to Quintschaf.\nWe rewrote the app from scratch, added many more features and crafted a new user interface to make the app easy to use for the average person. We rebranded to MyKeyboard, published it on the AppStore and the sales started coming in. I wouldn\u0026rsquo;t say that the app is a huge commercial success, but we have a very loyal and steadily growing user base. We\u0026rsquo;re getting feedback and feature suggestions almost daily and our users are very happy with the app, which really makes us feel that our continued effort of improving the app is worth every single minute.\nIn the beginning we were focusing on iPhone only, with little consideration for iPad users. An analysis of the usage data provided by Apple showed that almost nobody was using the app on iPad anyway, so we spent our time on improving the experience on iPhone only. After a bit more than a year, this suddenly changed. We saw an influx of new iPad users and an increasing number of people contacted us directly to ask about (better) iPad support. Up to this point, the user interface was almost unusable on iPad, keyboard dimensions were weird and the whole experience just wasn\u0026rsquo;t great.\nSo we sat down and started working on MyKeyboard 3. Two months and 100+ commits later, we shipped it. iPad support is great now, dimensions look and feel right, we introduced swipe-down support on keys to switch between alternate versions (like 2 and @) on the same key (similarly to the builtin iPad keyboard), and we made this feature available on iPhone too, because why not! We reworked the keyboard editor to be even more intuitive, added builtin support for more languages (Korean, Arabic, Chinese, \u0026hellip;), added both a split-screen and one-handed mode and fixed many bugs that accumulated over time.\nLater, we even built and shipped our own auto-correct engine, because the builtin one was just not good enough, and we\u0026rsquo;ve gotten a lot of positive feedback about this change. Auto-correct is now much more reliable and although there are still a few issues, we\u0026rsquo;re generally very happy with the results.\nThis whole experience has been amazing and we\u0026rsquo;re looking forward to further improving MyKeyboard.\nHarder, better, faster, stronger We had been working on MyKeyboard for a while now and we had learned a lot about software architecture, SwiftUI, and the AppStore. It was time to branch out some more, and so we started working on Chatalyzer, an analysis tool for WhatsApp, iMessage and Tinder chats. We released it in 2022, and by 2023 it had become our second biggest hit. We were clearly getting better at this, and things were slowly picking up speed.\nThe year of prototypes 2023 rolled around and we had many ideas that we wanted to try out. We started moving fast and built many prototypes to see what would be worth pursuing. I think we scrapped at least 5 projects that year that never saw any public release, but a few of the prototypes stuck around. We built quite a few open source libraries, such as MapItemPicker, Inspect, ChatView, SwiftUIElements and FoundationPlus. Interestingly, we didn\u0026rsquo;t release a single app that year, but we\u0026rsquo;re working on a few that will be released early 2024.\nWhat\u0026rsquo;s next? We\u0026rsquo;ve got a few new ideas and prototypes up our sleeves that are almost ready for prime-time. Until then, we\u0026rsquo;ve got a few more blog posts in the works that might be interesting to Swift/SwiftUI developers and people interested in the field of software architecture.\nSee you soon!\n","permalink":"https://blog.quintschaf.com/posts/welcome/","title":"Welcome"},{"content":"","permalink":"https://blog.quintschaf.com/categories/","title":"Categories"},{"content":"","permalink":"https://blog.quintschaf.com/tags/","title":"Tags"}]